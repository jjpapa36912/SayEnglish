//
//  ContentView.swift
//  EnglishChatApp
//
//  Created by YourName on 2024/08/29.
//

import SwiftUI
import AVFoundation
import Speech
import UserNotifications
import GoogleMobileAds

enum ChatLevel: String, Codable, CaseIterable {
    case beginner, intermediate, advanced
    
    var emoji: String {
        switch self {
        case .beginner: return "üü¢"
        case .intermediate: return "üü°"
        case .advanced: return "üî¥"
        }
    }
    var title: String {
        switch self {
        case .beginner: return "Beginner"
        case .intermediate: return "Intermediate"
        case .advanced: return "Advanced"
        }
    }
    var subtitle: String {
        switch self {
        case .beginner: return "Í∏∞Ï¥àÏ†ÅÏù∏ ÏùºÏÉÅ ÌëúÌòÑÎ∂ÄÌÑ∞ Ï∞®Í∑ºÏ∞®Í∑º"
        case .intermediate: return "Ïã§Ï†ú ÎåÄÌôîÏóê Í∞ÄÍπåÏö¥ Î¨∏Ïû• ÌõàÎ†®"
        case .advanced: return "ÏÉÅÌô©Î≥Ñ Ïã¨Ìôî ÎåÄÌôîÎ°ú Ïã§Ï†Ñ Í∞êÍ∞Å ÌÇ§Ïö∞Í∏∞"
        }
    }
    /// /chat/startÏóê Î≥¥ÎÇº ÌîÑÎ°¨ÌîÑÌä∏
    var seedPrompt: String {
            switch self {
            case .beginner: return "Let's practice basic daily English expressions step-by-step. Keep responses short, slow, and simple."
            case .intermediate: return "Let's practice real-life English dialogue. Give natural, moderately long replies and follow-up questions."
            case .advanced: return "Let's practice advanced scenario-based conversation. Give nuanced, challenging prompts and push fluency."
            }
        }
}

// MARK: - 1. Data Models (ÏÑúÎ≤ÑÏôÄ ÌÜµÏã†Ìï† Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞)
// FastAPI ÏÑúÎ≤ÑÏùò Pydantic Î™®Îç∏Í≥º ÎèôÏùºÌïú Íµ¨Ï°∞Î°ú CodableÏùÑ Ï±ÑÌÉùÌï©ÎãàÎã§.
struct ChatMessage: Identifiable, Codable, Equatable {
    let id = UUID()
    let role: String
    let text: String
}

// /chat/start ÏóîÎìúÌè¨Ïù∏Ìä∏ ÏùëÎãµ
struct StartResponse: Codable {
    let assistant_text: String
}
// ‚úÖ ÏöîÏ≤≠ DTOÏóê level Ï∂îÍ∞Ä
struct StartRequest: Codable {
    let prompt: String?
    let level: String
    init(prompt: String?, level: ChatLevel) {
        self.prompt = prompt
        self.level = level.rawValue
    }
}
// /chat/reply ÏóîÎìúÌè¨Ïù∏Ìä∏ ÏöîÏ≤≠
struct ReplyRequest: Codable {
    let history: [ChatMessage]
    let user_text: String
    let level: String
    init(history: [ChatMessage], user_text: String, level: ChatLevel) {
        self.history = history
        self.user_text = user_text
        self.level = level.rawValue
    }
}

// /chat/reply ÏóîÎìúÌè¨Ïù∏Ìä∏ ÏùëÎãµ
struct ReplyResponse: Codable {
    let assistant_text: String
}

// ‚úÖ Í∏∞Ï°¥ ChatSession ÍµêÏ≤¥
struct ChatSession: Identifiable, Codable, Equatable {
    let id: UUID
    let startTime: Date
    var messages: [ChatMessage]
    var totalSeconds: Int? = 0   // ‚úÖ Ï¥ù ÎåÄÌôîÏãúÍ∞Ñ(Ï¥à) Ï†ÄÏû•

    static func == (lhs: ChatSession, rhs: ChatSession) -> Bool {
        return lhs.id == rhs.id
    }
}



// ÏïåÎûå Îç∞Ïù¥ÌÑ∞ Î™®Îç∏
struct Alarm: Identifiable, Codable, Equatable {
    var id: String
    var type: AlarmType
    var time: Date
    var weekdays: Set<Int> // 1(ÏùºÏöîÏùº) ~ 7(ÌÜ†ÏöîÏùº)
    var interval: Int? // Ï£ºÍ∏∞ (Î∂Ñ Îã®ÏúÑ)
    var isActive: Bool
    
    // ÏïåÎûåÏùò ÏÇ¨Ïö©Ïûê ÏπúÌôîÏ†ÅÏù∏ ÏÑ§Î™Ö
    var description: String {
        switch type {
        case .daily:
            return "Îß§Ïùº \(formattedTime)"
        case .weekly:
            let days = weekdays.sorted().map {
                let formatter = DateFormatter()
                formatter.locale = Locale(identifier: "ko_KR")
                return formatter.weekdaySymbols[$0 - 1]
            }.joined(separator: ", ")
            return "\(days) \(formattedTime)"
        case .interval:
            return "\(interval!)Î∂ÑÎßàÎã§"
        }
    }
    
    var formattedTime: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm"
        return formatter.string(from: time)
    }
    
    // UNNotificationRequest ÏÉùÏÑ±
    func createNotificationRequest() -> UNNotificationRequest {
        let content = UNMutableNotificationContent()
        content.title = "ÏòÅÏñ¥ ÎåÄÌôî ÏïåÎûå"
        content.body = "ÏòÅÏñ¥ ÎåÄÌôîÌï† ÏãúÍ∞ÑÏûÖÎãàÎã§!"
        
        let alarmSounds = ["eng_prompt_01.wav", "eng_prompt_02.wav", "eng_prompt_03.wav", "eng_prompt_04.wav", "eng_prompt_05.wav"]
        if let randomSound = alarmSounds.randomElement() {
            content.sound = UNNotificationSound(named: UNNotificationSoundName(randomSound))
        } else {
            content.sound = .default
        }
        
        var trigger: UNNotificationTrigger?
        
        switch type {
        case .daily, .weekly:
            var dateComponents = Calendar.current.dateComponents([.hour, .minute, .timeZone], from: time)
            dateComponents.timeZone = .current
            
            if type == .weekly {
                let weekday = Calendar.current.component(.weekday, from: time)
                if !weekdays.contains(weekday) {
                    return UNNotificationRequest(identifier: self.id, content: content, trigger: nil)
                }
            }
            
            trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: true)
        case .interval:
            if let interval = self.interval, interval > 0 {
                trigger = UNTimeIntervalNotificationTrigger(timeInterval: TimeInterval(interval * 60), repeats: true)
            }
        }
        
        return UNNotificationRequest(identifier: self.id, content: content, trigger: trigger)
    }
}

enum AlarmType: String, CaseIterable, Codable {
    case daily = "Îß§Ïùº"
    case weekly = "ÏöîÏùºÎ≥Ñ"
    case interval = "ÏãúÍ∞Ñ Ï£ºÍ∏∞"
}

// MARK: - 2. Audio Controller
// ÏùåÏÑ± ÏûÖÎ†• Î∞è Ï∂úÎ†•ÏùÑ Í¥ÄÎ¶¨ÌïòÎäî ÌÅ¥ÎûòÏä§
class AudioController: NSObject, ObservableObject, SFSpeechRecognizerDelegate, AVSpeechSynthesizerDelegate, SFSpeechRecognitionTaskDelegate {
    
    private let speechRecognizer = SFSpeechRecognizer(locale: Locale(identifier: "en-US"))!
    private let synthesizer = AVSpeechSynthesizer()
    private var recognitionRequest: SFSpeechAudioBufferRecognitionRequest?
    private var recognitionTask: SFSpeechRecognitionTask?
    private let audioEngine = AVAudioEngine()
    
    private var silenceTimer: Timer?
    private let silenceTimeout: TimeInterval = 2.5
    
    weak var viewModel: ChatViewModel?

    @Published var isRecognizing = false
    @Published var recognizedText = ""
    @Published var isSpeaking = false
    
    override init() {
        super.init()
        speechRecognizer.delegate = self
        synthesizer.delegate = self
        requestAuthorization()
    }
    func stopSpeaking() {
            if synthesizer.isSpeaking {
                synthesizer.stopSpeaking(at: .immediate)
            }
        }
    deinit {
        silenceTimer?.invalidate()
    }
    
    func requestAuthorization() {
        SFSpeechRecognizer.requestAuthorization { authStatus in
            OperationQueue.main.addOperation {
                switch authStatus {
                case .authorized:
                    print("Speech recognition authorized.")
                default:
                    print("Speech recognition not authorized.")
                }
            }
        }
        AVAudioSession.sharedInstance().requestRecordPermission { granted in
            if granted {
                print("Microphone access granted.")
            } else {
                print("Microphone access not granted.")
            }
        }
    }
    
    func startRecognition() throws {
        guard let viewModel = viewModel, viewModel.isChatActive else { return }
        guard !synthesizer.isSpeaking else { return } // TTS Ï§ëÏù¥Î©¥ Î¨¥Ïãú

        recognitionTask?.cancel()
        recognitionTask = nil

        let session = AVAudioSession.sharedInstance()
        try session.setCategory(.playAndRecord,
                                mode: .voiceChat, // ‚úÖ ÏóêÏΩî Ï∫îÏä¨ÎßÅ
                                options: [.defaultToSpeaker, .allowBluetooth])
        try session.setPreferredSampleRate(44100)                // ‚úÖ STTÏôÄ Ïûò ÎßûÏùå
        try session.setPreferredIOBufferDuration(0.005)          // ‚úÖ ÏßÄÏó∞ Ï∂ïÏÜå
        try session.setActive(true, options: .notifyOthersOnDeactivation)

        let inputNode = audioEngine.inputNode
        inputNode.removeTap(onBus: 0)

        let req = SFSpeechAudioBufferRecognitionRequest()
        req.shouldReportPartialResults = true
        // ÌïÑÏöî Ïãú: on-deviceÎßå Ïì∞Í≥† Ïã∂Îã§Î©¥
        // req.requiresOnDeviceRecognition = true

        recognitionRequest = req
        recognitionTask = speechRecognizer.recognitionTask(with: req, delegate: self)

        let format = inputNode.outputFormat(forBus: 0)
        inputNode.installTap(onBus: 0, bufferSize: 1024, format: format) { buf, _ in
            self.recognitionRequest?.append(buf)
        }

        audioEngine.prepare()
        try audioEngine.start()

        isRecognizing = true
        resetSilenceTimer()

        // ‚úÖ Ïû¨ÏãúÏûë ÏõåÎ∞çÏóÖ Í∏∞Í∞Ñ ÏÑ§Ï†ï (ÏïÑÎûò 3)ÏóêÏÑú ÏÇ¨Ïö©Ìï† ÌîåÎûòÍ∑∏)
        warmupUntil = Date().addingTimeInterval(0.35)
    }

    
    func forceStopRecognition() {
        audioEngine.stop()
        recognitionRequest?.endAudio()
        isRecognizing = false
        silenceTimer?.invalidate()
        silenceTimer = nil
    }

    private func findPreferredVoice() -> AVSpeechSynthesisVoice? {
        let allVoices = AVSpeechSynthesisVoice.speechVoices()
        if let premiumVoice = allVoices.first(where: {
            $0.language == "en-US" && $0.quality == .premium
        }) {
            return premiumVoice
        }
        
        if let enhancedVoice = allVoices.first(where: {
            $0.language == "en-US" && $0.quality == .enhanced
        }) {
            return enhancedVoice
        }
        
        return AVSpeechSynthesisVoice(language: "en-US")
    }
    
    
    func speak(_ text: String) {
        if synthesizer.isSpeaking {
            synthesizer.stopSpeaking(at: .immediate)
        }
        
        forceStopRecognition()
        
        let utterance = AVSpeechUtterance(string: text)
        utterance.voice = findPreferredVoice()
        utterance.volume = 1.0
        synthesizer.speak(utterance)
    }
    private var warmupUntil: Date? = nil

    func speechRecognitionTask(_ task: SFSpeechRecognitionTask,
                               didHypothesizeTranscription t: SFTranscription) {
        // ‚úÖ Ïû¨ÏãúÏûë ÏõåÎ∞çÏóÖ ÏãúÍ∞Ñ ÎèôÏïàÏùÄ ÌååÏÖú Î¨¥Ïãú
        if let until = warmupUntil, Date() < until { return }
        self.recognizedText = t.formattedString
        resetSilenceTimer()
    }

    // MARK: - SFSpeechRecognitionTaskDelegate
    func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didChange state: SFSpeechRecognitionTaskState) {
    }
    
    func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didStartSpeechAt: Date) {
        resetSilenceTimer()
    }
    
    func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didFinishSpeech: SFSpeechRecognitionResult) {
    }
    
    
    
    func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didFinishSuccessfully successfully: Bool) {
    }
    func speechSynthesizer(_ s: AVSpeechSynthesizer, didFinish u: AVSpeechUtterance) {
        self.isSpeaking = false
        // ‚úÖ 0.3~0.4Ï¥à Îí§Ïóê STT Ïû¨Í∞ú
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.35) {
            try? self.startRecognition()
        }
    }

    
    // MARK: - AVSpeechSynthesizerDelegate
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didStart utterance: AVSpeechUtterance) {
        self.isSpeaking = true
    }
    
    
    
    private func resetSilenceTimer() {
        silenceTimer?.invalidate()
        silenceTimer = Timer.scheduledTimer(withTimeInterval: silenceTimeout, repeats: false) { [weak self] _ in
            if let recognizedText = self?.recognizedText, !recognizedText.isEmpty {
                self?.viewModel?.sendRecognizedText(recognizedText)
                self?.recognizedText = ""
            }
        }
    }
}

// MARK: - 3. ViewModel (Ïï±Ïùò Î°úÏßÅÏùÑ Îã¥Îãπ)
class ChatViewModel: ObservableObject {
    
    #if DEBUG
    private let serverURL = "http://fe18a029cc8f.ngrok-free.app"
    #else
    private let serverURL = "http://13.124.208.108:6490"
    #endif

    @Published var messages: [ChatMessage] = []
    @Published var isLoading = false
    @Published var errorMessage: String? = nil
    @Published var isChatActive: Bool = true
    @StateObject private var bannerCtrl = BannerAdController()   // ‚¨ÖÔ∏è Ï∂îÍ∞Ä
    @Published var currentLevel: ChatLevel = .beginner   // ‚¨ÖÔ∏è Ï∂îÍ∞Ä
    @Published var dailySentence: String = ""
    @Published var translation: String = ""   // ‚úÖ Ï∂îÍ∞Ä
    @Published var isDailyMode: Bool = false       // Ïò§ÎäòÏùò Î¨∏Ïû• ÎåÄÌôî Î™®Îìú Ïó¨Î∂Ä



    // ‚úÖ @Binding var selectedLevel: ChatLevel?       // ‚¨ÖÔ∏è Ï∂îÍ∞Ä
    @State private var showLevelSelect = false   // ‚¨ÖÔ∏è Ï∂îÍ∞ÄÏ∂îÍ∞Ä: ÌòÑÏû¨ ÏßÑÌñâ Ï§ëÏù∏ Ï±ÑÌåÖ ÏÑ∏ÏÖò
    @Published var currentSession: ChatSession?

    private var history: [ChatMessage] {
        return messages.filter { $0.role != "system" }
    }
    
    @Published var audioController: AudioController
    
    init() {
        let controller = AudioController()
        self.audioController = controller
        controller.viewModel = self
    }
    
    func startChatWithDailySentence() {
        Task {
            await fetchDailySentence()
            guard !dailySentence.isEmpty else { return }

            self.isDailyMode = true
            self.currentSession = ChatSession(id: UUID(), startTime: Date(), messages: [])

            do {
                let url = URL(string: "\(serverURL)/chat/start_daily")!
                var req = URLRequest(url: url)
                req.httpMethod = "POST"
                req.setValue("application/json", forHTTPHeaderField: "Content-Type")
                let body: [String: Any] = ["sentence": dailySentence, "level": currentLevel.rawValue]
                req.httpBody = try JSONSerialization.data(withJSONObject: body)

                let (data, _) = try await URLSession.shared.data(for: req)
                let res = try JSONDecoder().decode(StartResponse.self, from: data)

                let msg = ChatMessage(role: "assistant", text: res.assistant_text)
                await MainActor.run {
                    self.messages.append(msg)
                    self.currentSession?.messages.append(msg)
                    self.audioController.speak(res.assistant_text)
                }
            } catch {
                print("‚ùå Failed to start daily chat: \(error)")
            }
        }
    }

    // ‚úÖ ChatViewModel ÎÇ¥Î∂ÄÏóê DTO Ï∂îÍ∞Ä
    private struct DailyReplyReqDTO: Codable {
        let history: [[String: String]]
        let user_text: String
        let sentence: String
        let level: String
    }

    private struct DailyReplyResDTO: Codable {
        let assistant_text: String
    }
    @MainActor
    func fetchDailySentence() async {
        do {
            guard let url = URL(string: "\(serverURL)/daily_sentence") else { return }
            let (data, _) = try await URLSession.shared.data(from: url)
            struct DailySentenceResponse: Codable { let date: String; let sentence: String; let translation: String }
            let decoded = try JSONDecoder().decode(DailySentenceResponse.self, from: data)
            self.dailySentence = decoded.sentence
        } catch {
            print("‚ùå Failed to fetch daily sentence: \(error)")
        }
    }

    // ‚úÖ Ïò§ÎäòÏùò Î¨∏Ïû• ÌïôÏäµÏö© reply
    func sendDailyReply(userText: String, sentence: String) {
        // Î®ºÏ†Ä ÏÇ¨Ïö©Ïûê Î∞úÌôî UIÏóê Î∞òÏòÅ
        let userMsg = ChatMessage(role: "user", text: userText)
        DispatchQueue.main.async {
            self.messages.append(userMsg)
            self.currentSession?.messages.append(userMsg)
            self.isLoading = true
            self.errorMessage = nil
        }

        Task {
            do {
                // 1) ÌûàÏä§ÌÜ†Î¶¨ -> ÏÑúÎ≤Ñ Ïä§ÌÇ§Îßà([[String:String]])Î°ú Î≥ÄÌôò
                let historyPayload: [[String: String]] = self.messages
                    .filter { $0.role != "system" }
                    .map { ["role": $0.role, "text": $0.text] }

                // 2) Î∞îÎîîÎ•º Î™ÖÏãúÏ†Å DTOÎ°ú ÏÉùÏÑ± ‚Üí ÌÉÄÏûÖ Î™®Ìò∏ÏÑ± Ï†úÍ±∞
                let payload = DailyReplyReqDTO(
                    history: historyPayload,
                    user_text: userText,
                    sentence: sentence,
                    level: self.currentLevel.rawValue
                )
                let bodyData = try JSONEncoder().encode(payload)

                // 3) ÏöîÏ≤≠
                guard let url = URL(string: "\(serverURL)/chat/daily_reply") else { return }
                var req = URLRequest(url: url)
                req.httpMethod = "POST"
                req.setValue("application/json", forHTTPHeaderField: "Content-Type")
                req.httpBody = bodyData

                let (data, _) = try await URLSession.shared.data(for: req)

                // 4) ÏùëÎãµ ÎîîÏΩîÎî©
                let res = try JSONDecoder().decode(DailyReplyResDTO.self, from: data)

                // 5) Ïñ¥ÏãúÏä§ÌÑ¥Ìä∏ Î©îÏãúÏßÄ Î∞òÏòÅ + TTS
                let assistant = ChatMessage(role: "assistant", text: res.assistant_text)
                await MainActor.run {
                    self.messages.append(assistant)
                    self.currentSession?.messages.append(assistant)
                    self.isLoading = false
                    self.audioController.speak(assistant.text)
                }
            } catch {
                await MainActor.run {
                    self.isLoading = false
                    self.errorMessage = "Failed daily reply: \(error.localizedDescription)"
                }
                print("‚ùå Failed to send daily reply: \(error)")
            }
        }
    }

    // MARK: - Î†àÎ≤® Í∏∞Î∞ò ÏãúÏûë
    func startChat(level: ChatLevel) {
        guard messages.isEmpty else { return }
        self.currentLevel = level
        self.currentSession = ChatSession(id: UUID(), startTime: Date(), messages: [])

        Task {
            await MainActor.run {
                self.isLoading = true
                self.errorMessage = nil
            }
            do {
                let url = URL(string: "\(serverURL)/chat/start")!
                var req = URLRequest(url: url)
                req.httpMethod = "POST"
                req.setValue("application/json", forHTTPHeaderField: "Content-Type")
                let body = StartRequest(prompt: level.seedPrompt, level: level)
                req.httpBody = try JSONEncoder().encode(body)

                print("‚û°Ô∏è /chat/start\n\(req.curlString)")

                let t0 = Date()
                let (data, resp) = try await URLSession.shared.data(for: req)
                let ms = Int(Date().timeIntervalSince(t0) * 1000)

                guard let http = resp as? HTTPURLResponse else { throw URLError(.badServerResponse) }
                print("‚¨ÖÔ∏è /chat/start [\(http.statusCode)] \(ms)ms CT=\(http.value(forHTTPHeaderField: "Content-Type") ?? "-") bytes=\(data.count)")
                if http.statusCode != 200 {
                    print("‚õîÔ∏è RAW BODY:\n\(NetLog.prettyJSON(data))")
                    throw NSError(domain: "HTTP", code: http.statusCode,
                                  userInfo: [NSLocalizedDescriptionKey: "HTTP \(http.statusCode)"])
                }

                do {
                    let res = try JSONDecoder().decode(StartResponse.self, from: data)
                    print("‚úÖ Decoded StartResponse: \(res.assistant_text)")
                    let msg = ChatMessage(role: "assistant", text: res.assistant_text)
                    await MainActor.run {
                        self.messages.append(msg)
                        self.currentSession?.messages.append(msg)
                        self.isLoading = false
                        self.audioController.speak(res.assistant_text)
                    }
                } catch {
                    print("‚ùå Decode StartResponse failed: \(NetLog.decodeErrorDescription(error, data: data))")
                    print("üì¶ RAW JSON:\n\(NetLog.prettyJSON(data))")
                    throw error
                }
            } catch {
                await MainActor.run {
                    self.isLoading = false
                    self.errorMessage = "Failed to start chat: \(error.localizedDescription)"
                }
            }
        }
    }



    func startChat() {
        guard messages.isEmpty else { return }

        // ‚úÖ Ï∂îÍ∞Ä: ÏÉàÎ°úÏö¥ Ï±ÑÌåÖ ÏÑ∏ÏÖò ÏãúÏûë
        self.currentSession = ChatSession(id: UUID(), startTime: Date(), messages: [])

        Task {
            await MainActor.run {
                self.isLoading = true
                self.errorMessage = nil
            }
            
            do {
                let url = URL(string: "\(serverURL)/chat/start")!
                var request = URLRequest(url: url)
                request.httpMethod = "POST"
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                
                let body = ["prompt": "Hello! Would you like to practice some interesting expressions with me?"]
                request.httpBody = try JSONEncoder().encode(body)

                let (data, _) = try await URLSession.shared.data(for: request)
                let response = try JSONDecoder().decode(StartResponse.self, from: data)
                
                let assistantMessage = ChatMessage(role: "assistant", text: response.assistant_text)
                await MainActor.run {
                    self.messages.append(assistantMessage)
                    self.currentSession?.messages.append(assistantMessage) // ‚úÖ Ï∂îÍ∞Ä: ÏÑ∏ÏÖòÏóê Î©îÏãúÏßÄ Ï†ÄÏû•
                    self.isLoading = false
                    self.audioController.speak(response.assistant_text)
                }
            } catch {
                await MainActor.run {
                    self.isLoading = false
                    self.errorMessage = "Failed to start chat: \(error.localizedDescription)"
                }
            }
        }
    }
    
    func sendRecognizedText(_ text: String) {
        guard !text.isEmpty && !isLoading && isChatActive else { return }

        if isDailyMode {
            sendDailyReply(userText: text)   // ‚úÖ Ïò§ÎäòÏùò Î¨∏Ïû• ÌïôÏäµ ÌùêÎ¶Ñ
            return
        }

        // ‚¨áÔ∏è Í∏∞Ï°¥ ÏùºÎ∞ò ÎåÄÌôî ÌùêÎ¶Ñ (Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ)
        let userMessage = ChatMessage(role: "user", text: text)
        DispatchQueue.main.async {
            self.messages.append(userMessage)
            self.currentSession?.messages.append(userMessage)
            self.isLoading = true
            self.errorMessage = nil
        }
        Task {
            do {
                let url = URL(string: "\(serverURL)/chat/reply")!
                var req = URLRequest(url: url)
                req.httpMethod = "POST"
                req.setValue("application/json", forHTTPHeaderField: "Content-Type")
                let payload = ReplyRequest(history: history, user_text: userMessage.text, level: currentLevel)
                req.httpBody = try JSONEncoder().encode(payload)

                let (data, _) = try await URLSession.shared.data(for: req)
                let res = try JSONDecoder().decode(ReplyResponse.self, from: data)

                let assistant = ChatMessage(role: "assistant", text: res.assistant_text)
                await MainActor.run {
                    self.messages.append(assistant)
                    self.currentSession?.messages.append(assistant)
                    self.isLoading = false
                    self.audioController.speak(assistant.text)
                }
            } catch {
                await MainActor.run {
                    self.isLoading = false
                    self.errorMessage = "Failed to get AI response: \(error.localizedDescription)"
                }
            }
        }
    }

    private func sendDailyReply(userText: String) {
        let userMessage = ChatMessage(role: "user", text: userText)
        DispatchQueue.main.async {
            self.messages.append(userMessage)
            self.currentSession?.messages.append(userMessage)
            self.isLoading = true
            self.errorMessage = nil
        }

        Task {
            do {
                let url = URL(string: "\(serverURL)/chat/daily_reply")!
                var req = URLRequest(url: url)
                req.httpMethod = "POST"
                req.setValue("application/json", forHTTPHeaderField: "Content-Type")

                // ÏÑúÎ≤ÑÏóê historyÎ•º Msg Î∞∞Ïó¥ ÌòïÏãùÏúºÎ°ú ÎÑòÍπÄ
                let msgHist = self.history.map { ["role": $0.role, "text": $0.text] }
                let body: [String: Any] = [
                    "history": msgHist,
                    "user_text": userText,
                    "sentence": self.dailySentence,
                    "level": self.currentLevel.rawValue
                ]
                req.httpBody = try JSONSerialization.data(withJSONObject: body)

                let (data, _) = try await URLSession.shared.data(for: req)
                struct DailyReplyRes: Codable { let assistant_text: String }
                let res = try JSONDecoder().decode(DailyReplyRes.self, from: data)

                let assistant = ChatMessage(role: "assistant", text: res.assistant_text)
                await MainActor.run {
                    self.messages.append(assistant)
                    self.currentSession?.messages.append(assistant)
                    self.isLoading = false
                    self.audioController.speak(assistant.text)
                }
            } catch {
                await MainActor.run {
                    self.isLoading = false
                    self.errorMessage = "Failed daily reply: \(error.localizedDescription)"
                }
            }
        }
    }

    
    func endChat() {
        self.isChatActive = false
        self.isDailyMode = false           // ‚úÖ Î™®Îìú Î¶¨ÏÖã
        audioController.forceStopRecognition()
        self.messages.append(ChatMessage(role: "system", text: "ÎåÄÌôîÍ∞Ä Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§."))
    }

    
    func resumeChat() {
            // ‚úÖ Í∏∞Ï°¥ Î©îÏãúÏßÄ Ïú†ÏßÄÌïòÍ≥† ÎåÄÌôîÎßå Îã§Ïãú ÌôúÏÑ±Ìôî
            self.isChatActive = true

            // ‚úÖ ÏùåÏÑ± Ïù∏Ïãù Ïû¨ÏãúÏûë (ÏÉà /chat/start Ìò∏Ï∂ú X)
            try? self.audioController.startRecognition()
        }
}



// MARK: - 5. Views (UI Ïª¥Ìè¨ÎÑåÌä∏)
// ‚úÖ ChatView Ï†ÑÏ≤¥ ÍµêÏ≤¥
struct ChatView: View {
    @StateObject private var viewModel = ChatViewModel()
    @Binding var showChatView: Bool
    @EnvironmentObject var historyManager: ChatHistoryManager
    @StateObject private var bannerCtrl = BannerAdController()   // ‚¨ÖÔ∏è Ï∂îÍ∞Ä
    let mode: ChatMode               // ‚úÖ level or dailySentence
    var onExit: (() -> Void)? = nil            // ‚¨ÖÔ∏è Ï∂îÍ∞Ä




    // ÌÉÄÏù¥Î®∏ ÏÉÅÌÉú
    @State private var elapsedSec = 0
    private let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()

    private func fmt(_ sec: Int) -> String {
        let m = sec / 60, s = sec % 60
        return String(format: "%02d:%02d", m, s)
    }

    var body: some View {
        VStack(spacing: 0) {
            // ÏÉÅÎã® Î∞î
            HStack {
                //Îí§Î°úÍ∞ÄÍ∏∞ Î≤ÑÌäº
                Button(action: {
                    // ÎÇòÍ∞ÄÍ∏∞ Ï†Ñ: ÏÑ∏ÏÖò Ï†ÄÏû•(Ï¥ù ÎåÄÌôîÏãúÍ∞Ñ Ìè¨Ìï®) + ÏùåÏÑ± Ï§ëÏßÄ
                    if var session = viewModel.currentSession, !session.messages.isEmpty {
                        session.totalSeconds = elapsedSec
                        viewModel.currentSession = session
                        historyManager.saveChatSession(session)
                    }
                    viewModel.audioController.stopSpeaking()
                    onExit?()                                  // ‚¨ÖÔ∏è Ï∂îÍ∞Ä

                    withAnimation {
                        showChatView = false
                        viewModel.endChat()
                    }
                }) {
                    Image(systemName: "chevron.left")
                        .foregroundColor(.blue)
                }
                .padding(.horizontal)

                Spacer()
                Text("English Tutor")
                    .font(.headline)
                Spacer()

                // Ïö∞Ï∏° ÏÉÅÎã® ÌÉÄÏù¥Î®∏ ÌëúÏãú
                Text(fmt(elapsedSec))
                    .font(.footnote.monospacedDigit())
                    .foregroundColor(.secondary)
                    .padding(.trailing, 12)
            }
            .padding(.top)
            .padding(.bottom, 5)

            
            
            // ‚¨áÔ∏è Î∞∞ÎÑà
            BannerAdView(controller: bannerCtrl)
                .frame(height: 50)
                .padding(.bottom, 6)
            // Î©îÏãúÏßÄ Î¶¨Ïä§Ìä∏
            ScrollView {
                VStack(alignment: .leading, spacing: 15) {
                    ForEach(viewModel.messages) { message in
                        MessageView(message: message) {
                            if message.role == "assistant" {
                                viewModel.audioController.speak(message.text)
                            }
                        }
                    }
                }
                .padding()
            }
            .background(Color(.systemGray6))

            // ÏóêÎü¨/Î°úÎî©
            if let error = viewModel.errorMessage {
                Text(error)
                    .foregroundColor(.red)
                    .padding()
            }
            if viewModel.isLoading {
                ProgressView()
                    .padding()
            }

            // ÌïòÎã® Ïª®Ìä∏Î°§ (X = ÏùºÏãúÏ†ïÏßÄ / Ïû¨Í∞ú)
            AudioControlView(viewModel: viewModel)
                .padding()
                .background(Color(.systemBackground))
        }
        // ChatView Ïïà onAppear ÏàòÏ†ï
        .onAppear {
            if viewModel.messages.isEmpty {
                switch mode {
                case .level(let lvl):
                    viewModel.startChat(level: lvl)
                case .dailySentence:
                    viewModel.startChatWithDailySentence()
                }
            } else {
                try? viewModel.audioController.startRecognition()
            }
        }


        .onDisappear {
            // Îã§Î•∏ ÌôîÎ©¥ÏúºÎ°ú ÎÇòÍ∞à ÎïåÎäî TTSÎßå Ï¶âÏãú Ï§ëÏßÄ
            viewModel.audioController.stopSpeaking()
        }
        // 1Ï¥àÎßàÎã§ Í≤ΩÍ≥ºÏãúÍ∞Ñ Ï¶ùÍ∞Ä(ÎåÄÌôî ÌôúÏÑ± ÏÉÅÌÉúÏóêÏÑúÎßå)
        .onReceive(timer) { _ in
            if viewModel.isChatActive {
                elapsedSec += 1
            }
        }
        // ‚ùå Ïû¨Í∞ú Ïãú ÌÉÄÏù¥Î®∏Î•º Î¶¨ÏÖãÌïòÎäî ÏΩîÎìú(Ïòà: onChangeÏóêÏÑú elapsedSec=0)Îäî ÎëêÏßÄ ÏïäÏäµÎãàÎã§.
    }
}


struct MessageView: View {
    let message: ChatMessage
    let action: () -> Void
    
    var isUser: Bool { message.role == "user" }
    
    var body: some View {
        HStack {
            if isUser {
                Spacer()
            } else {
                Button(action: action) {
                    Image(systemName: "speaker.wave.3.fill")
                        .foregroundColor(.blue)
                    }
                }
            
            Text(message.text)
                .padding(10)
                .background(message.role == "user" ? Color.blue : Color(.systemGray4))
                .foregroundColor(message.role == "user" ? .white : .black)
                .cornerRadius(12)
                .frame(maxWidth: 300, alignment: message.role == "user" ? .trailing : .leading)
            
            if !isUser {
                Spacer()
            }
        }
    }
}

struct AudioControlView: View {
    @ObservedObject var viewModel: ChatViewModel

    var body: some View {
        if viewModel.isChatActive {
            HStack {
                Spacer()
                if viewModel.audioController.isRecognizing {
                    Text("Listening...")
                        .foregroundColor(.gray)
                } else if !viewModel.audioController.recognizedText.isEmpty {
                    Text(viewModel.audioController.recognizedText)
                        .lineLimit(1)
                        .truncationMode(.tail)
                        .foregroundColor(.black)
                } else {
                    Text("ÎßêÏîÄÌï¥Ï£ºÏÑ∏Ïöî...")
                        .foregroundColor(.gray)
                }
                Spacer()

                Button(action: {
                    viewModel.endChat()
                }) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.largeTitle)
                        .foregroundColor(.red)
                }
            }
        } else {
            HStack {
                Spacer()
                Button(action: {
                    viewModel.resumeChat()
                }) {
                    Image(systemName: "arrow.clockwise.circle.fill")
                        .font(.largeTitle)
                        .foregroundColor(.green)
                }
                Text("Ïû¨Í∞ú")
                    .foregroundColor(.green)
                Spacer()
            }
        }
    }
}

// ‚úÖ ÎåÄÌôî Í∏∞Î°ù Ïû¨ÏÉù(TTS)Îßå Ï∂îÍ∞ÄÌïú DetailedChatView
struct DetailedChatView: View {
    let session: ChatSession
    @Environment(\.dismiss) var dismiss
    @StateObject private var bannerCtrl = BannerAdController()   // ‚¨ÖÔ∏è Ï∂îÍ∞Ä

    // Î°úÏª¨ TTS Ï†ÑÏö© Ìï©ÏÑ±Í∏∞ (ChatViewModelÏóê ÏùòÏ°¥ X)
    @State private var synthesizer = AVSpeechSynthesizer()
    
    // ÏÉÅÏÑ∏Î∑∞ Ï†ÑÏö© Î≥¥Ïù¥Ïä§ ÏÑ†ÌÉù
    private func preferredVoice() -> AVSpeechSynthesisVoice? {
        // premium ‚Üí enhanced ‚Üí Í∏∞Î≥∏(en-US) Ïö∞ÏÑ†
        if let v = AVSpeechSynthesisVoice.speechVoices().first(where: { $0.language == "en-US" && $0.quality == .premium }) {
            return v
        }
        if let v = AVSpeechSynthesisVoice.speechVoices().first(where: { $0.language == "en-US" && $0.quality == .enhanced }) {
            return v
        }
        return AVSpeechSynthesisVoice(language: "en-US")
    }
    
    private func speak(_ text: String) {
        if synthesizer.isSpeaking {
            synthesizer.stopSpeaking(at: .immediate)
        }
        let u = AVSpeechUtterance(string: text)
        u.voice = preferredVoice()
        u.volume = 1.0
        synthesizer.speak(u)
    }

    var body: some View {
        VStack(spacing: 0) {
            HStack {
                Button(action: {
                    // ‚úÖ Îí§Î°ú Í∞ÄÍ∏∞ ÏßÅÏ†Ñ Ï§ëÏßÄ(Ï≤¥Í∞ê Ï¶âÏãú)
                                        if synthesizer.isSpeaking {
                                            synthesizer.stopSpeaking(at: .immediate)
                                        }
                    
                    dismiss() }) {
                    Image(systemName: "chevron.left")
                        .foregroundColor(.blue)
                }
                .padding(.horizontal)
                
                Spacer()
                Text("English Tutor")
                    .font(.headline)
                Spacer()
            }
            .padding(.top)
            .padding(.bottom, 5)
            // ‚¨áÔ∏è Î∞∞ÎÑà
                        BannerAdView(controller: bannerCtrl)
                            .frame(height: 50)
                            .padding(.bottom, 6)
            ScrollView {
                VStack(alignment: .leading, spacing: 15) {
                    ForEach(session.messages) { message in
                        // ‚úÖ Ïó¨Í∏∞Îßå Î≥ÄÍ≤Ω: Ïä§ÌîºÏª§ ÌÉ≠ Ïãú TTS Ïû¨ÏÉù
                        MessageView(message: message) {
                            if message.role == "assistant" {
                                speak(message.text)
                            }
                        }
                    }
                }
                .padding()
            }
            .background(Color(.systemGray6))
        }
        .navigationTitle(Text(session.startTime, format: .dateTime.hour().minute().day().month()))
        .navigationBarTitleDisplayMode(.inline)
        // ‚úÖ ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Îì± Ïñ¥Îñ§ Ïù¥Ïú†Î°úÎì† ÌôîÎ©¥Ïù¥ ÏÇ¨ÎùºÏßà ÎïåÎèÑ Î≥¥Ïû•
                .onDisappear {
                    if synthesizer.isSpeaking {
                        synthesizer.stopSpeaking(at: .immediate)
                    }
                }
    }
}



// ‚úÖ ÏÑ∏Î†®Îêú Î©îÏù∏ ÌôîÎ©¥ (Ï†ÑÏ≤¥ ÍµêÏ≤¥)
// ‚úÖ ÏÑ∏Î†® ÎîîÏûêÏù∏ + ÏïåÎûå 5Í∞ú Ï†úÌïú ÌåùÏóÖ Ìè¨Ìï® MainView (Ï†ÑÏ≤¥ ÍµêÏ≤¥)
// ‚úÖ ÏÑ∏Î†® ÎîîÏûêÏù∏ + ÏïåÎûå 5Í∞ú Ï†úÌïú ÌåùÏóÖ Ìè¨Ìï® MainView (ÏÑ∏ÏÖò Î™©Î°ùÏùÄ Î≥ÑÎèÑ ÌéòÏù¥ÏßÄÎ°ú Ïù¥Îèô)
struct MainView: View {
    @State private var selectedTab: AlarmType = .daily
    @State private var selectedTime = Date()
    @State private var selectedWeekdays: Set<Int> = []
    @State private var selectedInterval: Double = 30
    @StateObject private var bannerCtrl = BannerAdController()   // ‚¨ÖÔ∏è Ï∂îÍ∞Ä
//    @Binding var selectedLevel: ChatLevel?       // ‚¨ÖÔ∏è Ï∂îÍ∞Ä
//        @State private var showLevelSelect = false   // ‚¨ÖÔ∏è Ï∂îÍ∞Ä
    var onTapStart: (() -> Void)? = nil        // ‚¨ÖÔ∏è Ï∂îÍ∞Ä
    @StateObject private var sentenceVM = DailySentenceViewModel()



    @EnvironmentObject var historyManager: ChatHistoryManager
    @Binding var showChatView: Bool

    private let weekdays = ["Ïùº","Ïõî","Ìôî","Ïàò","Î™©","Í∏à","ÌÜ†"]

    @State private var now = Date()
    private let minuteTicker = Timer.publish(every: 60, on: .main, in: .common).autoconnect()

    @State private var showAlarmLimitAlert = false

    private func mmss(_ sec: Int) -> String {
        let m = sec / 60, s = sec % 60
        return String(format: "%02d:%02d", m, s)
    }

    var body: some View {
        ZStack {
            LinearGradient(
                colors: [Color.purple.opacity(0.25), Color.indigo.opacity(0.25)],
                startPoint: .topLeading, endPoint: .bottomTrailing
            )
            .ignoresSafeArea()

            NavigationView {
                ScrollView {
                    VStack(spacing: 18) {

                        BannerAdView(controller: bannerCtrl)
                                                    .frame(height: 50) // ÌëúÏ§Ä 320x50
                                                    .padding(.top, 6)
                        
                        // ÏÉÅÎã® Î∞î: ÌÉÄÏù¥ÌãÄ + [ÌûàÏä§ÌÜ†Î¶¨] [ÏÑ∏ÏÖò] ÏïÑÏù¥ÏΩò
                        HStack(spacing: 10) {
                            Text("English Bell")
                                .font(.largeTitle.bold())
                                .foregroundColor(.primary)

                            Spacer()


                            // ‚úÖ ÏÉàÎ°ú: ÎÇ†Ïßú Î™©Î°ù ÌéòÏù¥ÏßÄÎ°ú Ïù¥Îèô
                                NavigationLink {
                                    DatesListView()
                                } label: {
                                    Image(systemName: "clock.arrow.circlepath")
                                        .font(.title3.weight(.semibold))
                                        .foregroundColor(.purple)
                                        .padding(8)
                                        .background(Color.white.opacity(0.55), in: Circle())
                                }
                                .accessibilityLabel("ÎÇ†ÏßúÎ≥Ñ Î™©Î°ù")
  
                        }
                        .padding(.horizontal, 16)
                        .padding(.top, 6)

                        // Ïπ¥Îìú 1: ÌÉ≠ + Ï†ÄÏû•
                        SectionCard {
                            HStack(spacing: 12) {
                                Picker("ÏïåÎûå Ïú†Ìòï", selection: $selectedTab) {
                                    Text(AlarmType.daily.rawValue).tag(AlarmType.daily)
                                    Text(AlarmType.weekly.rawValue).tag(AlarmType.weekly)
                                    Text(AlarmType.interval.rawValue).tag(AlarmType.interval)
                                }
                                .pickerStyle(.segmented)

                                Button {
                                    let newAlarm: Alarm
                                    if selectedTab == .interval {
                                        newAlarm = Alarm(id: "", type: .interval,
                                                         time: Date(), weekdays: [],
                                                         interval: Int(selectedInterval), isActive: true)
                                    } else {
                                        newAlarm = Alarm(id: "", type: selectedTab,
                                                         time: selectedTime, weekdays: selectedWeekdays,
                                                         interval: nil, isActive: true)
                                    }
                                    let ok = historyManager.addAlarm(alarm: newAlarm) // Bool Î∞òÌôò ÌïÑÏàò
                                    if !ok { showAlarmLimitAlert = true }
                                } label: {
                                    Text("Ï†ÄÏû•").font(.headline)
                                }
                                .buttonStyle(.borderedProminent)
                            }
                        }

                        // Ïπ¥Îìú 2: ÏÉÅÏÑ∏ ÏÑ§Ï†ï
                        SectionCard(spacing: 14) {
                            if selectedTab == .daily || selectedTab == .weekly {
                                VStack(alignment: .leading, spacing: 8) {
                                    Text("ÏãúÍ∞Ñ ÏÑ†ÌÉù")
                                        .font(.headline)
                                    DatePicker("", selection: $selectedTime, displayedComponents: .hourAndMinute)
                                        .labelsHidden()
                                        .datePickerStyle(.wheel)
                                        .frame(height: 100)
                                }
                            }

                            if selectedTab == .weekly {
                                VStack(alignment: .leading, spacing: 8) {
                                    Text("ÏöîÏùº ÏÑ†ÌÉù")
                                        .font(.headline)
                                    FlowWeekdays(labels: weekdays, selected: $selectedWeekdays)
                                }
                            }

                            if selectedTab == .interval {
                                VStack(alignment: .leading, spacing: 8) {
                                    HStack {
                                        Text("ÏïåÎûå Ï£ºÍ∏∞")
                                            .font(.headline)
                                        Spacer()
                                        Text("\(Int(selectedInterval))Î∂Ñ")
                                            .font(.headline.monospacedDigit())
                                            .foregroundStyle(.secondary)
                                    }
                                    Slider(value: $selectedInterval, in: 5...60, step: 5)
                                        .tint(.purple)
                                }
                            }
                        }

                        SectionCard {
                            VStack(alignment: .leading, spacing: 8) {
                                Text("Ïò§ÎäòÏùò Î¨∏Ïû•")
                                    .font(.headline)

                                if sentenceVM.dailySentence.isEmpty {
                                    Text("Î∂àÎü¨Ïò§Îäî Ï§ë...")
                                        .foregroundColor(.secondary)
                                } else {
                                    Text("‚Äú\(sentenceVM.dailySentence)‚Äù")
                                        .font(.title3)
                                        .fontWeight(.semibold)
                                        .padding(.top, 4)
                                    Text(sentenceVM.translation)
                                        .font(.subheadline)
                                        .foregroundColor(.secondary)
                                }
                            }
                        }
                        .onAppear {
                            sentenceVM.fetchDailySentence()
                        }




                        // ÎåÄÌôîÌïòÍ∏∞ Î≤ÑÌäº
                        // ÎåÄÌôîÌïòÍ∏∞ Î≤ÑÌäº
                        Button {
                            onTapStart?()                              // ‚¨ÖÔ∏è Î†àÎ≤® ÏÑ†ÌÉù ÎùÑÏö∞Í∏∞ Ïã†Ìò∏Îßå Î≥¥ÎÉÑ
                        } label: {
                            HStack(spacing: 10) {
                                Image(systemName: "waveform.circle.fill")
                                    .font(.system(size: 22, weight: .semibold))
                                Text("ÎåÄÌôîÌïòÍ∏∞")
                                    .font(.headline)
                            }
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 14)
                            .foregroundColor(.white)
                            .background(
                                LinearGradient(colors: [Color.purple, Color.indigo],
                                               startPoint: .leading, endPoint: .trailing)
                            )
                            .cornerRadius(14)
                            .shadow(color: Color.indigo.opacity(0.25), radius: 12, x: 0, y: 8)
                        }
                        .padding(.horizontal, 16)
//                        // ‚¨áÔ∏è Î†àÎ≤® ÏÑ†ÌÉù ÌíÄÏä§ÌÅ¨Î¶∞
//                        .fullScreenCover(isPresented: $showLevelSelect) {
//                            LevelSelectView { level in
//                                self.selectedLevel = level
//                                self.showLevelSelect = false
//                                self.showChatView = true
//                            }
//                        }


                        // Ïò§Îäò ÏßÑÌñâ
                        let todaySeconds = historyManager.seconds(for: now)
                        let progress = min(Double(todaySeconds) / 3600.0, 1.0)

                        SectionCard {
                            VStack(spacing: 10) {
                                HStack {
                                    Text("Ïò§Îäò ÎåÄÌôî")
                                        .font(.headline)
                                    Spacer()
                                    Text("\(mmss(todaySeconds)) / 60:00")
                                        .font(.subheadline.monospacedDigit())
                                        .foregroundStyle(.secondary)
                                }
                                GradientProgressBar(progress: progress)
                                    .frame(height: 16)
                            }
                        }
                        // ‚úÖ ÏïåÎûå Ï†ÄÏû• Î™©Î°ù Ïπ¥Îìú (Ïò§Îäò ÎåÄÌôî Ïπ¥Îìú ÏïÑÎûòÏóê Ï∂îÍ∞Ä)
                        SectionCard {
                            VStack(alignment: .leading, spacing: 12) {
                                Text("ÎÇ¥ ÏïåÎûå Î™©Î°ù (ÏµúÎåÄ 5Í∞ú)")
                                    .font(.headline)

                                if historyManager.alarms.isEmpty {
                                    Text("Îì±Î°ùÎêú ÏïåÎûåÏù¥ ÏóÜÏäµÎãàÎã§.")
                                        .foregroundStyle(.secondary)
                                } else {
                                    ForEach(historyManager.alarms) { alarm in
                                        HStack {
                                            Text(alarm.description)
                                                .font(.subheadline)
                                            Spacer()
                                            Toggle("", isOn: Binding(
                                                get: { alarm.isActive },
                                                set: { _ in historyManager.toggleAlarm(id: alarm.id) }
                                            ))
                                            .labelsHidden()
                                            .tint(.purple)

                                            Button {
                                                historyManager.deleteAlarm(id: alarm.id)
                                            } label: {
                                                Image(systemName: "trash.fill")
                                                    .foregroundColor(.red)
                                            }
                                            .buttonStyle(.plain)
                                        }
                                        .padding(.vertical, 6)

                                        Divider().opacity(0.15)
                                    }
                                }
                            }
                        }


                        // ‚úÖ ÌïòÎã® ‚ÄúÎåÄÌôî Í∏∞Î°ù‚Äù ÏÑπÏÖòÏùÄ Ï†úÍ±∞Îê® (SessionsListViewÎ°ú Ïù¥Îèô)

                        Spacer(minLength: 10)
                    }
                    .padding(.bottom, 16)
                }
                .scrollIndicators(.hidden)
                .onAppear {
                    historyManager.loadChatSessions()
                    now = Date()
                }
                .onReceive(minuteTicker) { _ in
                    now = Date()
                }
                .background(Color.clear)
                .navigationBarHidden(true)
            }
            .navigationViewStyle(.stack)   // ‚úÖ iPadÏóêÏÑúÎèÑ Îã®Ïùº ÌôîÎ©¥(Ïä§ÌÉù)Î°ú ÌëúÏãú

        }
        .alert("Ï†ÄÏû•Ìï† Ïàò ÏóÜÏñ¥ÏöîüòÇ", isPresented: $showAlarmLimitAlert) {
            Button("ÌôïÏù∏", role: .cancel) { }
        } message: {
            Text("ÏïåÎûåÏùÄ ÏµúÎåÄ 5Í∞úÍπåÏßÄ Ï†ÄÏû•Ìï† Ïàò ÏûàÏñ¥Ïöî.")
        }
    }
}

//
// MARK: - Reusable UI
//

fileprivate struct SectionCard<Content: View>: View {
    var spacing: CGFloat = 12
    @ViewBuilder var content: () -> Content

    var body: some View {
        VStack(alignment: .leading, spacing: spacing) {
            content()
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 18)
                .fill(.thinMaterial)
                .overlay(
                    RoundedRectangle(cornerRadius: 18)
                        .stroke(Color.white.opacity(0.35), lineWidth: 1)
                )
        )
        .shadow(color: Color.black.opacity(0.07), radius: 12, x: 0, y: 6)
        .padding(.horizontal, 16)
    }
}

fileprivate struct FlowWeekdays: View {
    let labels: [String]
    @Binding var selected: Set<Int>

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 8) {
                ForEach(1..<8) { weekday in
                    let isOn = selected.contains(weekday)
                    Text(labels[weekday - 1])
                        .font(.subheadline.weight(.semibold))
                        .padding(.horizontal, 12)
                        .padding(.vertical, 8)
                        .background(isOn ? Color.purple : Color.white.opacity(0.6))
                        .foregroundColor(isOn ? .white : .primary)
                        .overlay(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(Color.purple.opacity(0.5), lineWidth: isOn ? 0 : 1)
                        )
                        .cornerRadius(12)
                        .onTapGesture {
                            if isOn { selected.remove(weekday) } else { selected.insert(weekday) }
                        }
                }
            }
            .padding(.vertical, 2)
        }
        .frame(maxWidth: .infinity)
    }
}


// ‚úÖ ÏÉàÎ°ú Ï∂îÍ∞Ä: ÏÑ∏ÏÖò Î™©Î°ù ÌéòÏù¥ÏßÄ (Îí§Î°úÍ∞ÄÍ∏∞ Ìè¨Ìï®)
struct SessionsListView: View {
    @EnvironmentObject var historyManager: ChatHistoryManager
    @Environment(\.dismiss) var dismiss

    private func mmss(_ sec: Int) -> String {
        let m = sec / 60, s = sec % 60
        return String(format: "%02d:%02d", m, s)
    }

    var body: some View {
        ZStack {
            LinearGradient(
                colors: [Color.purple.opacity(0.9), Color.indigo.opacity(0.9)],
                startPoint: .topLeading, endPoint: .bottomTrailing
            )
            .ignoresSafeArea()

            VStack(spacing: 0) {
                // ÏÉÅÎã® Î∞î
                HStack(spacing: 12) {
                    Button {
                        dismiss()
                    } label: {
                        Image(systemName: "chevron.left")
                            .font(.title3.weight(.semibold))
                            .foregroundColor(.white)
                            .padding(8)
                            .background(Color.white.opacity(0.15), in: Circle())
                    }

                    Spacer()

                    Text("ÏÑ∏ÏÖò Î™©Î°ù")
                        .font(.headline)
                        .foregroundColor(.white)

                    Spacer()

                    Color.clear.frame(width: 36, height: 36)
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 8)

                // Î¶¨Ïä§Ìä∏ (ÏµúÏã† Ïö∞ÏÑ†, ÏµúÎåÄ 5Í∞úÎäî Ï†ÄÏû• Ï†ïÏ±ÖÏóê ÏùòÌï¥ ÏûêÎèô Ï†úÌïú)
                List {
                    ForEach(historyManager.chatSessions) { session in
                        NavigationLink(destination: DetailedChatView(session: session)) {
                            HStack {
                                Text(session.startTime, format: .dateTime.hour().minute().day().month())
                                    .font(.subheadline)
                                Spacer()
                                Text(mmss(session.totalSeconds ?? 0))
                                    .font(.subheadline.monospacedDigit())
                                    .foregroundStyle(.secondary)
                            }
                            .padding(.vertical, 6)
                        }
                    }
                    .onDelete { indexSet in
                        indexSet.forEach { idx in
                            let id = historyManager.chatSessions[idx].id
                            historyManager.deleteChatSession(id: id)
                        }
                    }
                }
                .listStyle(.insetGrouped)
            }
        }
        .navigationBarBackButtonHidden(true)
    }
}



/// Í∞ÄÎ≥Ä Ï§ÑÎ∞îÍøà HStack (ÌÉúÍ∑∏ Î†àÏù¥ÏïÑÏõÉ)
fileprivate struct FlexibleWrapHStack<Content: View>: View {
    var spacing: CGFloat = 8
    var runSpacing: CGFloat = 8
    @ViewBuilder var content: () -> Content

    var body: some View {
        var width = CGFloat.zero
        var height = CGFloat.zero
        return GeometryReader { g in
            ZStack(alignment: .topLeading) {
                content()
                    .alignmentGuide(.leading) { d in
                        if (abs(width - d.width) > g.size.width) {
                            width = 0
                            height -= (d.height + runSpacing)
                        }
                        let result = width
                        width -= (d.width + spacing)
                        return result
                    }
                    .alignmentGuide(.top) { _ in
                        let result = height
                        return result
                    }
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
        .frame(minHeight: 0)
    }
}




// ‚úÖ Ï∂îÍ∞Ä: Î≥¥Îùº Í∑∏ÎùºÎç∞Ïù¥ÏÖò ÌîÑÎ°úÍ∑∏Î†àÏä§Î∞î
struct GradientProgressBar: View {
    let progress: Double // 0.0 ~ 1.0

    var body: some View {
        GeometryReader { geo in
            let width = max(0, min(1, progress)) * geo.size.width
            ZStack(alignment: .leading) {
                // Ìä∏Îûô
                RoundedRectangle(cornerRadius: 10)
                    .fill(.ultraThinMaterial)
                    .overlay(
                        RoundedRectangle(cornerRadius: 10)
                            .stroke(Color.white.opacity(0.25), lineWidth: 1)
                    )
                // Ï±ÑÏõåÏßÑ Î∂ÄÎ∂Ñ
                RoundedRectangle(cornerRadius: 10)
                    .fill(
                        LinearGradient(
                            colors: [Color.purple, Color.indigo],
                            startPoint: .leading, endPoint: .trailing
                        )
                    )
                    .frame(width: width)
                    .overlay(
                        RoundedRectangle(cornerRadius: 10)
                            .strokeBorder(Color.white.opacity(0.2))
                    )
            }
        }
        .frame(height: 16)
    }
}

// ‚úÖ ÍµêÏ≤¥: ChatHistoryManager (ÏÑ∏ÏÖòÏùÄ 'ÏµúÍ∑º 10Ïùº'Îßå Ïú†ÏßÄ, ÌïòÎ£® ÎÇ¥ ÏÑ∏ÏÖòÏùÄ Î¨¥Ï†úÌïú)
class ChatHistoryManager: ObservableObject {
    private let chatSessionsKey = "savedChatSessions"
    private let keepDays = 10                          // ‚úÖ ÏµúÍ∑º 10Ïùº Ïú†ÏßÄ

    @Published var alarms: [Alarm] = []
    private let alarmsKey = "savedAlarms"

    @Published var chatSessions: [ChatSession] = []

    init() {
        loadAlarms()
        loadChatSessions()
    }

    // MARK: - Chat History Management
    func loadChatSessions() {
        if let savedSessions = UserDefaults.standard.data(forKey: chatSessionsKey),
           let decoded = try? JSONDecoder().decode([ChatSession].self, from: savedSessions) {
            self.chatSessions = decoded
        } else {
            self.chatSessions = []
        }
        pruneToLastDays() // ‚úÖ Î°úÎìúÌïòÎ©¥ÏÑú 10Ïùº Ïù¥ÎÇ¥Îßå ÎÇ®Í∏∞Í∏∞
        self.chatSessions.sort { $0.startTime > $1.startTime }
    }

    func saveChatSession(_ session: ChatSession) {
        if let idx = chatSessions.firstIndex(where: { $0.id == session.id }) {
            chatSessions[idx] = session
        } else {
            chatSessions.insert(session, at: 0) // ÏµúÏã† Î®ºÏ†Ä
        }
        pruneToLastDays() // ‚úÖ Ï†ÄÏû•Ìï† ÎïåÎßàÎã§ 10Ïùº Ï¥àÍ≥ºÎ∂Ñ Ï†úÍ±∞
        persistChatSessions()
    }

    func deleteChatSession(id: UUID) {
        chatSessions.removeAll { $0.id == id }
        persistChatSessions()
    }

    private func persistChatSessions() {
        if let encoded = try? JSONEncoder().encode(chatSessions) {
            UserDefaults.standard.set(encoded, forKey: chatSessionsKey)
        }
    }

    /// ‚úÖ ÏµúÍ∑º 10ÏùºÎßå ÎÇ®Í∏∞Í∏∞ (startOfDay Í∏∞Ï§Ä)
    private func pruneToLastDays() {
        let cal = Calendar.current
        let startToday = cal.startOfDay(for: Date())
        guard let cutoff = cal.date(byAdding: .day, value: -(keepDays - 1), to: startToday) else { return }
        chatSessions = chatSessions.filter { s in
            cal.startOfDay(for: s.startTime) >= cutoff
        }
    }

    // MARK: - Aggregations (Ïò§Îäò Ìï©Í≥Ñ Î∞è ÎÇ†ÏßúÎ≥Ñ Ìï©Í≥Ñ)
    /// ÌäπÏ†ï ÎÇ†Ïßú(ÌòÑÏßÄ) Ï¥ù ÎàÑÏ†Å Ï¥à
    func seconds(for date: Date) -> Int {
        let cal = Calendar.current
        let sod = cal.startOfDay(for: date)
        let eod = cal.date(byAdding: .day, value: 1, to: sod)!
        return chatSessions.reduce(0) { acc, s in
            (s.startTime >= sod && s.startTime < eod) ? acc + (s.totalSeconds ?? 0) : acc
        }
    }

    /// ÏµúÍ∑º 10ÏùºÏùò ÎÇ†ÏßúÎ≥Ñ Ï¥ùÌï© (ÏµúÏã† ÎÇ†Ïßú Ïö∞ÏÑ†)
    func dailyTotals() -> [(date: Date, seconds: Int)] {
        let cal = Calendar.current
        var bucket: [Date: Int] = [:] // key = startOfDay

        for s in chatSessions {
            let day = cal.startOfDay(for: s.startTime)
            bucket[day, default: 0] += (s.totalSeconds ?? 0)
        }
        // Ïù¥ÎØ∏ pruneÎêòÏñ¥ 10Ïùº Ïù¥ÎÇ¥Îßå ÏûàÏùå
        return bucket
            .map { ($0.key, $0.value) }
            .sorted { $0.0 > $1.0 }
    }

    /// ÌäπÏ†ï ÎÇ†ÏßúÏùò ÏÑ∏ÏÖò Î¶¨Ïä§Ìä∏(ÏµúÏã† Ïö∞ÏÑ†)
    func sessions(on date: Date) -> [ChatSession] {
        let cal = Calendar.current
        return chatSessions
            .filter { cal.isDate($0.startTime, inSameDayAs: date) }
            .sorted { $0.startTime > $1.startTime }
    }

    // MARK: - Alarm Management (Í∏∞Ï°¥ Í∑∏ÎåÄÎ°ú)
    private func saveAlarms() {
        if let encoded = try? JSONEncoder().encode(alarms) {
            UserDefaults.standard.set(encoded, forKey: alarmsKey)
        }
    }

    private func loadAlarms() {
        if let savedAlarms = UserDefaults.standard.data(forKey: alarmsKey),
           let decoded = try? JSONDecoder().decode([Alarm].self, from: savedAlarms) {
            self.alarms = decoded
        } else {
            self.alarms = []
        }
    }

    /// ‚ö†Ô∏è addAlarmÏùÄ Ïù¥Ï†Ñ ÎãµÎ≥ÄÏ≤òÎüº Bool Î∞òÌôòÏúºÎ°ú Ïù¥ÎØ∏ Î∞îÍø®Îã§Îäî Ï†ÑÏ†ú (5Í∞ú Ï†úÌïú Ïú†ÏßÄ)
    func addAlarm(alarm: Alarm) -> Bool {
        guard alarms.count < 5 else { return false }
        var newAlarm = alarm
        if newAlarm.id.isEmpty { newAlarm.id = UUID().uuidString }
        alarms.append(newAlarm)
        scheduleNotification(for: newAlarm)
        saveAlarms()
        return true
    }

    func toggleAlarm(id: String) {
        if let index = alarms.firstIndex(where: { $0.id == id }) {
            alarms[index].isActive.toggle()
            if alarms[index].isActive {
                scheduleNotification(for: alarms[index])
            } else {
                UNUserNotificationCenter.current()
                    .removePendingNotificationRequests(withIdentifiers: [alarms[index].id])
            }
            saveAlarms()
        }
    }

    func deleteAlarm(id: String) {
        UNUserNotificationCenter.current().removePendingNotificationRequests(withIdentifiers: [id])
        alarms.removeAll(where: { $0.id == id })
        saveAlarms()
    }

    private func identifiers(for alarm: Alarm) -> [String] {
        switch alarm.type {
        case .weekly:
            return alarm.weekdays.map { "\(alarm.id)_w\($0)" }
        default:
            return [alarm.id]
        }
    }

    private func scheduleNotification(for alarm: Alarm) {
        UNUserNotificationCenter.current()
            .removePendingNotificationRequests(withIdentifiers: identifiers(for: alarm))
        guard alarm.isActive else { return }

        let center = UNUserNotificationCenter.current()

        switch alarm.type {
        case .weekly:
            let content = UNMutableNotificationContent()
            content.title = "ÏòÅÏñ¥ ÎåÄÌôî ÏïåÎûå"
            content.body = "ÏòÅÏñ¥ ÎåÄÌôîÌï† ÏãúÍ∞ÑÏûÖÎãàÎã§!"
            let alarmSounds = ["eng_prompt_01.wav","eng_prompt_02.wav","eng_prompt_03.wav","eng_prompt_04.wav","eng_prompt_05.wav"]
            content.sound = alarmSounds.randomElement().map { UNNotificationSound(named: UNNotificationSoundName($0)) } ?? .default

            let hm = Calendar.current.dateComponents([.hour, .minute], from: alarm.time)
            for wd in alarm.weekdays {
                var dc = hm; dc.weekday = wd
                let trigger = UNCalendarNotificationTrigger(dateMatching: dc, repeats: true)
                let id = "\(alarm.id)_w\(wd)"
                center.add(UNNotificationRequest(identifier: id, content: content, trigger: trigger)) { err in
                    if let err = err { print("Ï£ºÍ∞Ñ ÏïåÎûå Ïä§ÏºÄÏ§Ñ Ïã§Ìå®(\(wd)): \(err)") }
                }
            }

        case .daily, .interval:
            let request = alarm.createNotificationRequest()
            if request.trigger != nil {
                center.add(request) { error in
                    if let error = error { print("ÏïåÎ¶º Ïä§ÏºÄÏ§ÑÎßÅ Ïã§Ìå®: \(error.localizedDescription)") }
                }
            }
        }
    }
}
// ‚úÖ ÏÉà ÌéòÏù¥ÏßÄ 1: ÎÇ†Ïßú Î™©Î°ù (ÏµúÍ∑º 10Ïùº, Ìï©Í≥ÑÏôÄ ÏßÑÌñâÎ•† ÌëúÏãú)
struct DatesListView: View {
    @EnvironmentObject var historyManager: ChatHistoryManager
    @Environment(\.dismiss) var dismiss

    @StateObject private var bannerCtrl = BannerAdController()   // ‚¨ÖÔ∏è Ï∂îÍ∞Ä

    private func mmss(_ sec: Int) -> String {
        let m = sec / 60, s = sec % 60
        return String(format: "%02d:%02d", m, s)
    }

    var body: some View {
        ZStack {
            LinearGradient(colors: [Color.purple.opacity(0.9), Color.indigo.opacity(0.9)],
                           startPoint: .topLeading, endPoint: .bottomTrailing)
            .ignoresSafeArea()

            VStack(spacing: 0) {
                // ÏÉÅÎã® Î∞î
                HStack(spacing: 12) {
                    Button { dismiss() } label: {
                        Image(systemName: "chevron.left")
                            .font(.title3.weight(.semibold))
                            .foregroundColor(.white)
                            .padding(8)
                            .background(Color.white.opacity(0.15), in: Circle())
                    }
                    Spacer()
                    Text("ÎÇ†ÏßúÎ≥Ñ Í∏∞Î°ù")
                        .font(.headline)
                        .foregroundColor(.white)
                    Spacer()
                    Color.clear.frame(width: 36, height: 36)
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 8)

                // ‚¨áÔ∏è Î∞∞ÎÑà (ÏÉÅÎã® Î∞î Î∞îÎ°ú ÏïÑÎûò)
                                BannerAdView(controller: bannerCtrl)
                                    .frame(height: 50)
                                    .padding(.bottom, 8)
                // ÎÇ†Ïßú Î¶¨Ïä§Ìä∏
                ScrollView {
                    VStack(spacing: 14) {
                        ForEach(historyManager.dailyTotals(), id: \.date) { (day, seconds) in
                            let progress = min(Double(seconds) / 3600.0, 1.0)
                            NavigationLink {
                                SessionsByDateView(date: day)
                            } label: {
                                VStack(alignment: .leading, spacing: 10) {
                                    HStack {
                                        Text(day, format: .dateTime.year().month().day())
                                            .font(.headline)
                                            .foregroundColor(.primary)
                                        Spacer()
                                        Text("\(mmss(seconds)) / 60:00")
                                            .font(.subheadline.monospacedDigit())
                                            .foregroundColor(.secondary)
                                    }
                                    GradientProgressBar(progress: progress)
                                        .frame(height: 16)
                                }
                                .padding(16)
                                .background(
                                    RoundedRectangle(cornerRadius: 16)
                                        .fill(.thinMaterial)
                                        .overlay(
                                            RoundedRectangle(cornerRadius: 16)
                                                .stroke(Color.white.opacity(0.35), lineWidth: 1)
                                        )
                                )
                                .shadow(color: Color.black.opacity(0.15), radius: 10, x: 0, y: 6)
                                .padding(.horizontal, 16)
                            }
                        }

                        if historyManager.dailyTotals().isEmpty {
                            VStack(spacing: 8) {
                                Image(systemName: "calendar.badge.clock")
                                    .font(.system(size: 42))
                                    .foregroundColor(.white.opacity(0.85))
                                Text("ÌëúÏãúÌï† ÎÇ†ÏßúÍ∞Ä ÏóÜÏñ¥Ïöî")
                                    .foregroundColor(.white.opacity(0.95))
                                Text("ÎåÄÌôîÎ•º ÏãúÏûëÌï¥ Í∏∞Î°ùÏùÑ ÏåìÏïÑÎ≥¥ÏÑ∏Ïöî!")
                                    .foregroundColor(.white.opacity(0.85))
                                    .font(.subheadline)
                            }
                            .padding(.top, 40)
                        }
                    }
                    .padding(.vertical, 12)
                }
            }
        }
        .navigationBarBackButtonHidden(true)
    }
}

// ‚úÖ ÏÉà ÌéòÏù¥ÏßÄ 2: ÌäπÏ†ï ÎÇ†ÏßúÏùò ÏÑ∏ÏÖò Î™©Î°ù
struct SessionsByDateView: View {
    let date: Date
    @EnvironmentObject var historyManager: ChatHistoryManager
    @Environment(\.dismiss) var dismiss
    @StateObject private var bannerCtrl = BannerAdController()   // ‚¨ÖÔ∏è Ï∂îÍ∞Ä

    private func mmss(_ sec: Int) -> String {
        let m = sec / 60, s = sec % 60
        return String(format: "%02d:%02d", m, s)
    }

    var body: some View {
        ZStack {
            LinearGradient(colors: [Color.purple.opacity(0.9), Color.indigo.opacity(0.9)],
                           startPoint: .topLeading, endPoint: .bottomTrailing)
            .ignoresSafeArea()

            VStack(spacing: 0) {
                // ÏÉÅÎã® Î∞î
                HStack(spacing: 12) {
                    Button { dismiss() } label: {
                        Image(systemName: "chevron.left")
                            .font(.title3.weight(.semibold))
                            .foregroundColor(.white)
                            .padding(8)
                            .background(Color.white.opacity(0.15), in: Circle())
                    }
                    Spacer()
                    Text(date, format: .dateTime.year().month().day())
                        .font(.headline)
                        .foregroundColor(.white)
                    Spacer()
                    Color.clear.frame(width: 36, height: 36)
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 8)
                // ‚¨áÔ∏è Î∞∞ÎÑà
                                BannerAdView(controller: bannerCtrl)
                                    .frame(height: 50)
                                    .padding(.bottom, 8)
                // ÏÑ∏ÏÖò Î¶¨Ïä§Ìä∏
                List {
                    ForEach(historyManager.sessions(on: date)) { session in
                        NavigationLink(destination: DetailedChatView(session: session)) {
                            VStack(alignment: .leading, spacing: 6) {
                                Text(session.startTime, format: .dateTime.hour().minute())
                                    .font(.subheadline)
                                Text(mmss(session.totalSeconds ?? 0))
                                    .font(.subheadline.monospacedDigit())
                                    .foregroundColor(.secondary)
                            }
                            .padding(.vertical, 6)
                        }
                    }
                    .onDelete { indexSet in
                        indexSet.forEach { idx in
                            let id = historyManager.sessions(on: date)[idx].id
                            historyManager.deleteChatSession(id: id)
                        }
                    }
                }
                .listStyle(.insetGrouped)
            }
        }
        .navigationBarBackButtonHidden(true)
    }
}


// ‚úÖ ÏÉàÎ°ú Ï∂îÍ∞Ä: DailyHistoryView
// ‚úÖ Í∏∞Ï°¥ DailyHistoryView Ï†ÑÏ≤¥ ÍµêÏ≤¥(Î≥¥Îùº Í∑∏ÎùºÎç∞Ïù¥ÏÖò + Ïπ¥ÎìúÌòï ÏÖÄ)
struct DailyHistoryView: View {
    @EnvironmentObject var historyManager: ChatHistoryManager
    @Environment(\.dismiss) var dismiss

    // ÏµúÍ∑º NÏùº ÌïÑÌÑ∞ (ÏõêÌïòÎ©¥ 7/30Ïùº ÌÜ†Í∏Ä)
    @State private var dayWindow: Int = 30

    private func mmss(_ sec: Int) -> String {
        let m = sec / 60, s = sec % 60
        return String(format: "%02d:%02d", m, s)
    }

    private var filteredTotals: [(date: Date, seconds: Int)] {
        let all = historyManager.dailyTotals()
        guard dayWindow > 0 else { return all }
        let cal = Calendar.current
        let cutoff = cal.date(byAdding: .day, value: -dayWindow + 1, to: cal.startOfDay(for: Date())) ?? Date.distantPast
        return all.filter { $0.date >= cutoff }
    }

    var body: some View {
        ZStack {
            // ‚úÖ Î∞∞Í≤Ω Î≥¥Îùº Í∑∏ÎùºÎç∞Ïù¥ÏÖò
            LinearGradient(
                colors: [Color.purple.opacity(0.9), Color.indigo.opacity(0.9)],
                startPoint: .topLeading, endPoint: .bottomTrailing
            )
            .ignoresSafeArea()

            VStack(spacing: 0) {
                // ÏÉÅÎã® Ïª§Ïä§ÌÖÄ Î∞î
                HStack(spacing: 12) {
                    Button {
                        dismiss()
                    } label: {
                        Image(systemName: "chevron.left")
                            .font(.title3.weight(.semibold))
                            .foregroundColor(.white)
                            .padding(8)
                            .background(Color.white.opacity(0.15), in: Circle())
                    }

                    Spacer()

                    Text("ÌûàÏä§ÌÜ†Î¶¨")
                        .font(.headline)
                        .foregroundColor(.white)

                    Spacer()

                    // Ïò§Î•∏Ï™Ω Ïó¨Î∞± Ï†ïÎ†¨Ïö©
                    Color.clear.frame(width: 36, height: 36)
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 8)

                // Í∏∞Í∞Ñ ÏÑ†ÌÉù (ÏÑ†ÌÉùÏÇ¨Ìï≠)
                HStack(spacing: 8) {
                    ForEach([7, 14, 30], id: \.self) { d in
                        Button {
                            dayWindow = d
                        } label: {
                            Text("\(d)Ïùº")
                                .font(.subheadline.weight(.semibold))
                                .foregroundColor(dayWindow == d ? .purple : .white)
                                .padding(.horizontal, 12)
                                .padding(.vertical, 6)
                                .background(
                                    RoundedRectangle(cornerRadius: 10)
                                        .fill(Color.white.opacity(dayWindow == d ? 0.95 : 0.18))
                                )
                        }
                    }
                }
                .padding(.horizontal, 16)
                .padding(.bottom, 6)

                // ÎÇ¥Ïö© Ïπ¥Îìú Î¶¨Ïä§Ìä∏
                ScrollView {
                    VStack(spacing: 14) {
                        ForEach(filteredTotals, id: \.date) { (day, seconds) in
                            let progress = min(Double(seconds) / 3600.0, 1.0)

                            // Ïπ¥Îìú ÏÖÄ
                            VStack(alignment: .leading, spacing: 10) {
                                HStack(alignment: .firstTextBaseline) {
                                    Text(day, format: .dateTime.year().month().day())
                                        .font(.headline)
                                        .foregroundColor(.primary)
                                    Spacer()
                                    Text("\(mmss(seconds)) / 60:00")
                                        .font(.subheadline.monospacedDigit())
                                        .foregroundColor(.secondary)
                                }

                                GradientProgressBar(progress: progress)
                                    .frame(height: 16)
                            }
                            .padding(16)
                            .background(
                                // Ïú†Î¶¨ Ïπ¥Îìú ÎäêÎÇå
                                RoundedRectangle(cornerRadius: 16)
                                    .fill(.thinMaterial)
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 16)
                                            .stroke(Color.white.opacity(0.35), lineWidth: 1)
                                    )
                            )
                            .shadow(color: Color.black.opacity(0.15), radius: 10, x: 0, y: 6)
                            .padding(.horizontal, 16)
                        }

                        // Îπà ÏÉÅÌÉú ÏïàÎÇ¥
                        if filteredTotals.isEmpty {
                            VStack(spacing: 8) {
                                Image(systemName: "bubble.left.and.bubble.right")
                                    .font(.system(size: 42))
                                    .foregroundColor(.white.opacity(0.8))
                                Text("ÏïÑÏßÅ ÎåÄÌôî Í∏∞Î°ùÏù¥ ÏóÜÏñ¥Ïöî")
                                    .foregroundColor(.white.opacity(0.95))
                                Text("Ïò§ÎäòÎ∂ÄÌÑ∞ 60Î∂Ñ Î™©ÌëúÎ•º Ï±ÑÏõåÎ≥¥ÏÑ∏Ïöî!")
                                    .foregroundColor(.white.opacity(0.8))
                                    .font(.subheadline)
                            }
                            .padding(.top, 40)
                        }
                    }
                    .padding(.vertical, 12)
                }
            }
        }
        .navigationBarBackButtonHidden(true)
    }
}


// MARK: - 6. App Entry Point
@main
struct EnglishChatAppApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    
    // ‚úÖ Ï∂îÍ∞Ä: Ïï± Ï†ÑÏ≤¥ÏóêÏÑú Í≥µÏú†Ìï† ChatHistoryManager
    @StateObject private var historyManager = ChatHistoryManager()

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(historyManager) // ‚úÖ Ï∂îÍ∞Ä: ÌôòÍ≤Ω Í∞ùÏ≤¥Î°ú Ï£ºÏûÖ
        }
    }
}

// MARK: - AppDelegate for UNUserNotificationCenterDelegate
class AppDelegate: NSObject, UIApplicationDelegate, UNUserNotificationCenterDelegate {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
        UNUserNotificationCenter.current().delegate = self
        requestNotificationPermission()
//        GADMobileAds.sharedInstance().start(completionHandler: nil)

        return true
    }

    // ÏïåÎ¶º Í∂åÌïú ÏöîÏ≤≠
    func requestNotificationPermission() {
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
            if granted {
                print("Notification permission granted.")
            } else {
                print("Notification permission denied.")
            }
        }
    }

    // ForegroundÏóêÏÑú ÏïåÎ¶ºÏù¥ Ïò¨ Îïå ÌëúÏãú
    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        completionHandler([.banner, .sound, .badge])
    }
}

struct ContentView: View {
    @State private var showChatView = false
    @State private var selectedMode: ChatMode? = nil    // ‚úÖ Î≥ÄÍ≤Ω
    @State private var showLevelSelect = false        // ‚¨ÖÔ∏è Î†àÎ≤® ÏÑ†ÌÉùÏùÑ ÏµúÏÉÅÏúÑÏóêÏÑú Í¥ÄÎ¶¨
    

    var body: some View {
           ZStack {
               if showChatView {
                   ChatView(
                       showChatView: $showChatView,
                       mode: selectedMode ?? .level(.beginner),   // ‚úÖ Í∏∞Î≥∏Í∞íÏùÄ beginner
                       onExit: {
                           showLevelSelect = true   // Îí§Î°úÍ∞ÄÍ∏∞ ‚Üí Î†àÎ≤® ÏÑ†ÌÉù Îã§Ïãú Ïó¥Í∏∞
                       }
                   )
               } else {
                   MainView(
                    onTapStart: { showLevelSelect = true }, showChatView: $showChatView   // ‚úÖ Î†àÎ≤® ÏÑ†ÌÉù ÎùÑÏö∞Í∏∞
                      )
               }
           }
           // ‚¨áÔ∏è Î†àÎ≤® ÏÑ†ÌÉùÏùÄ Ìï≠ÏÉÅ ÏµúÏÉÅÏúÑÏóêÏÑú ÎùÑÏõÄ(Î©îÏù∏/Ï±ÑÌåÖÍ≥º ÎèÖÎ¶Ω)
           .fullScreenCover(isPresented: $showLevelSelect) {
               LevelSelectView { mode in
                   selectedMode = mode
                   showLevelSelect = false
                   showChatView = true                        // ‚¨ÖÔ∏è ÏÑ†ÌÉù Ï¶âÏãú ChatView ÏßÑÏûÖ
               }
           }
       }
}
